
= Technical specification

The base currency is called power, represented as $P:=p_k -> rho$ in blockchain state.

Each peer has

+ a master privatekey $s_k$
+ many kinds of publickeys, depending on context
  - typically $"poseidon2"(s_k | "context_string")$, as a publickey
  - pre quantum crypto may be used, but it must be hashed first.

For any given moment, a full node stores

+ the mapping of power $P="enc"(p_k,k) -> "enc"(rho,k)$
  - which means the mapping is private
  - $k=H_2(H_1("sk" | #quote([power_map])) | "random"_1)$
    - $H_1$ separates the storage of sk and $H_1$, which increases security
    - $H_2$ ensures perfect forward secrecy for account balance.
    - Both publickeys and balances are encrypted.
  - enc is any secure symmetric cipher, or hash function.
+ mapping of contract state $C = "enc"(c,k) -> s | s in FF_q$
  - contract is identified by a hash over the ZK circuit
  - only valid proofs of this contract may update the state
  - contract can change its address as long as it follows the protocol, which ensures anonymity
  - contract address anonymity can be preserved when Tx pool is privately encrypted to the block producer, and the producer discards all transaction proofs.


== Contract address anonymity by block producer (proposal)

#let dim(it) = text(fill: luma(32.55%))[#it]

The contract update proof

$
  cases(
    "pub": c_1 dim("contract address"),
    "proof of correct update" s_1 -> s_2
  )
$

Block producer produces proof

$
  cases(
    "zk proof" s_1 -> s_2 dim("both are state root hashes") \
    "new state tree" \
    "enc"(k,->"next producer")
  )
$

Miners are selected proportionally to their power by VRF, to sign blocks. They don't produce blocks.

The pool of miners act as mixers of contracts. We want it to be large. We don't want sybils to get in either.

All signing is done through ZK, which is anonymous.

== Delegated Power

$
  "effective voting power" phi "is total raw power minus total delegated power" \
  sum phi = S
$

Delegation is a reversible transfer, where the delegator can reverse the transaction.

Delegator generates a proof as the transaction, encrypts it with a key generated by PQ-KEM, to the delegatee.

The ZK proof proves that the delegator has enough balance, and intends to delegate power. 

The delegatee generates a ZK proof that wraps the transcation in and updates his balance, which reveals a nullifier.

The delegator can revert ths transfer any time by adding the nullifier to the 'reverted Tx set'

== Commitment tree

We consider a tree, in the chain state, which consists of leaves of only hashes. 

Generate a ZK proof over contract update, whose public output include contract address, and get its hash.

Generate another proof showing that there exists such a proof that updates contract X such that X is within the state tree over state root Y, and publicly output the inner proof to have hash $omega$

Upon receiving this commitment, the block producer can not know what contract it is about, which provides anonymity.

The actual transaction can be published later, to actually modify chain state.

== Stateless blockchain

If we ignore the state tree, and only focus on the commitment tree, it counts as a stateless blockchain. 

In this case it's a growing merkle tree that pins hashes. In many cases we don't do transactions, we just need to pin some hashes to a point of time. 

The caveat here is the need to defend against spam attacks.

== On-demand block production


#let more_visible(it) = text(fill: rgb("#817503"))[#it]

There is no limit on block time. 

+ Transactions include a field about #more_visible("finality urgency")
+ Blocks are produced more when there are ongoing fork disputes

